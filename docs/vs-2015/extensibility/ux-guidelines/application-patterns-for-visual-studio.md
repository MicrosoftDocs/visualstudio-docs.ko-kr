---
title: 애플리케이션 패턴
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-sdk
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
caps.latest.revision: 8
ms.author: gregvanl
manager: jillfra
ms.openlocfilehash: af70b191e4b9061d08acdc7f76ade843dee41709
ms.sourcegitcommit: d9254e54079ae01cdf2d07b11f988faf688f80fc
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88114126"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio의 애플리케이션 패턴
[!INCLUDE[vs2017banner](../../includes/vs2017banner.md)]

## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a>창 상호 작용

### <a name="overview"></a>개요
 Visual Studio에서 사용 되는 두 가지 기본 창 형식은 문서 편집기와 도구 창입니다. 드문 경우 지만 가능 하지만 매우 드문 경우입니다. 이는 셸에서 모두 모덜리스 이지만 패턴은 근본적으로 다릅니다. 이 항목에서는 문서 창, 도구 창 및 모덜리스 대화 상자의 차이점에 대해 설명 합니다. 모달 대화 상자 패턴은 [대화 상자](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)에서 다룹니다.

### <a name="comparing-window-usage-patterns"></a>창 사용 패턴 비교
 **문서 창은** 거의 항상 문서 웰에 표시 됩니다. 그러면 문서 편집기에 추가 도구 창을 정렬 하는 "중심 단계"가 제공 됩니다.

 **도구 창은** IDE의 가장자리에 대해 표시 하거나 숨기 거 나 자동으로 숨길 수 있는 별도의 작은 창으로 표시 되는 경우가 가장 많습니다. 그러나 경우에 따라 창에서 **창/도킹** 속성을 취소 하 여 문서 내에 표시 되는 경우도 있습니다. 이로 인해 더 많은 공간을 확보 하 고 일반적인 설계 결정을 내릴 수 있습니다. Visual Studio에 통합을 시도할 때 기능에서 도구 창이 나 문서 창을 표시할지 여부를 결정 해야 합니다.

 **모덜리스 대화 상자** 는 Visual Studio에서 권장 되지 않습니다. 이러한 확장은 매우 광범위 하기 때문에 정의-부동 도구 창으로 구현 해야 합니다. 모덜리스 대화 상자는 셸 측면에 도킹 된 일반 도구 창의 크기가 너무 제한 되는 경우에 허용 됩니다. 사용자가 대화 상자를 보조 모니터로 이동할 가능성이 있는 경우에도 허용 됩니다.

 필요한 컨테이너 유형을 신중 하 게 생각 합니다. UI 디자인에 대 한 일반적인 사용 패턴 고려 사항은 다음 표에 나와 있습니다.

||문서 창|도구 창|모덜리스 대화 상자|
|-|---------------------|-----------------|---------------------|
|**Position**|항상 문서 내에 배치 되 고 IDE의 가장자리 주위에 도킹 되지 않습니다. 주 셸에서 별도로 부동 되도록 "끌어올 수 있습니다".|일반적으로 IDE의 가장자리 주위에 도킹 하지만 부동, 자동 숨기기 (고정 해제) 또는 문서 내에 도킹 되도록 사용자 지정할 수 있습니다.|IDE와는 별개의 부동 창입니다.|
|**모델 커밋**|*지연 된 커밋*<br /><br /> 문서에 데이터를 저장 하기 위해 사용자는 파일/저장, 다른 이름으로 저장 또는 모두 저장 명령을 실행 해야 합니다. 문서 창에는 데이터의 개념이 "변경 된" 되 고 저장 명령 중 하나에 커밋됩니다. 문서 창을 닫을 때 모든 내용이 디스크에 저장 되거나 손실 됩니다.|*즉시 커밋*<br /><br /> 저장 모델이 없습니다. 파일을 편집 하는 데 도움이 되는 검사기 도구 창의 경우 활성 편집기 또는 디자이너에서 파일을 열고 편집기나 디자이너에서 저장을 소유 해야 합니다.|*지연 또는 즉시 커밋*<br /><br /> 가장 자주 사용 되는 모덜리스 대화 상자에는 변경 내용을 커밋하는 작업이 필요 하며, 대화 세션 내에서 변경한 내용을 롤백하는 "취소" 작업을 허용 합니다.  그러면 도구 창에서 모덜리스 대화 상자를 구분할 수 있습니다 .이 도구 창에는 항상 즉시 커밋 모델이 있습니다.|
|**표시 유형**|*열기/만들기 (파일) 및 닫기*<br /><br /> 문서 창을 열려면 기존 문서를 열거나 템플릿을 사용 하 여 새 문서를 만드는 작업을 수행 합니다. "열기 \<specific editor> " 명령은 없습니다.|*숨기기 및 표시*<br /><br /> 단일 인스턴스 도구 창을 숨기 거 나 표시할 수 있습니다. 도구 창의 내용 및 상태는 보기 또는 숨김 상태에 상관 없이 유지 됩니다. 다중 인스턴스 도구 창을 닫을 뿐만 아니라 숨길 수도 있습니다. 다중 인스턴스 도구 창이 닫히면 도구 창 내의 내용 및 상태가 삭제 됩니다.|*명령에서 시작 됨*<br /><br /> 대화는 태스크 기반 명령에서 시작 됩니다.|
|**인스턴스**|*다중 인스턴스*<br /><br /> 여러 편집기를 동시에 열고 여러 파일을 편집할 수 있지만, 일부 편집기에서는 두 개 이상의 편집기에서 동일한 파일을 열 수 있습니다 ( **창 > 새 창** 명령 사용).<br /><br /> 단일 편집기에서 한 번에 하나 또는 여러 개의 파일을 편집할 수 있습니다 (프로젝트 디자이너).|*단일 또는 다중 인스턴스*<br /><br /> 콘텐츠는 속성 브라우저에서와 같이 컨텍스트를 반영 하거나 다른 창으로 포커스/컨텍스트를 푸시합니다 (작업 목록, 솔루션 탐색기).<br /><br /> 단일 인스턴스 및 다중 인스턴스 도구 창 모두 활성 문서 창에 연결 해야 합니다.|*단일 인스턴스*|
|**예**|**텍스트**편집기 (예: 코드 편집기)<br /><br /> 폼 디자이너 또는 모델링 화면과 같은 **디자인 화면**<br /><br /> 매니페스트 디자이너와 같은 **대화 상자와 비슷한 컨트롤 레이아웃**|**솔루션 탐색기** 는 솔루션에 포함 된 솔루션 및 프로젝트를 제공 합니다.<br /><br /> **서버 탐색기** 은 사용자가 창에서 열도록 선택한 서버 및 데이터 연결에 대 한 계층 구조 보기를 제공 합니다. 쿼리 등의 데이터베이스 계층에서 개체를 열면 문서 창이 열리며 사용자가 쿼리를 편집할 수 있습니다.<br /><br /> **속성 브라우저** 는 문서 창이 나 다른 도구 창에서 선택한 개체의 속성을 표시 합니다. 속성은 계층적 그리드 보기 또는 복잡 한 대화 상자와 같은 컨트롤에 표시 되며 사용자가 해당 속성에 대 한 값을 설정할 수 있습니다.||

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a>도구 창

### <a name="overview"></a>개요
 도구 창은 문서 창에서 발생 하는 사용자의 작업을 지원 합니다. Visual Studio에서 제공 하 고 조작할 수 있는 기본 루트 개체를 나타내는 계층을 표시 하는 데 사용할 수 있습니다.

 IDE에서 새 도구 창을 고려할 때 작성자는 다음을 수행 해야 합니다.

- 작업에 적합 한 기존 도구 창을 사용 하 고 유사한 기능을 사용 하 여 새 도구 창을 만들지 않습니다. 새 도구 창은 비슷한 창에 통합 될 수 없는 "도구" 또는 기능을 많이 제공 하거나 기존 창을 피벗 허브로 전환 하는 경우에만 만들어야 합니다.

- 필요한 경우 도구 창의 맨 위에서 표준 명령 모음을 사용 합니다.

- 다른 도구 창에 이미 있는 패턴 (컨트롤 표시 및 키보드 탐색의 경우)과 일치 해야 합니다.

- 다른 도구 창의 컨트롤 프레젠테이션과 일치 해야 합니다.

- 문서 특정 도구 창은 부모 문서가 활성화 될 때만 나타나도록 가능 하면 자동으로 표시 되어야 합니다.

- 키보드에서 창 콘텐츠를 탐색할 수 있는지 확인 합니다 (지원 화살표 키).

#### <a name="tool-window-states"></a>도구 창 상태
 Visual Studio 도구 창에는 서로 다른 상태가 있으며, 그 중 일부는 사용자가 활성화 됩니다 (자동 숨기기 기능 등). 자동 표시와 같은 기타 상태를 사용 하면 도구 창을 올바른 컨텍스트에 표시 하 고 필요 하지 않은 경우 숨길 수 있습니다. 총 5 개의 도구 창 상태가 있습니다.

- **도킹/고정** 도구 창은 문서 영역의 네 면 중 하나에 연결할 수 있습니다. 압정 아이콘이 도구 창 제목 표시줄에 나타납니다. 도구 창은 셸 및 기타 도구 창의 가장자리를 따라 가로 또는 세로로 도킹할 수 있으며 탭으로 연결 될 수도 있습니다.

- **자동 숨겨진** 도구 창은 고정 해제 되어 있습니다. 창에는 탭 (도구 창 및 아이콘 이름)이 문서 영역의 가장자리에 그대로 남아 있을 수 있습니다. 사용자가 탭을 마우스로 가리키면 도구 창이 출력 됩니다.

- 편집기 등의 다른 UI를 시작 하거나 포커스를 얻을 때 자동 **으로 표시 되는 도구 창이** 자동으로 표시 됩니다.

- **부동** 도구 창은 IDE 외부에서 가리킵니다. 다중 모니터 구성에 유용 합니다.

- **탭 문서** 도구 창을 문서 웰에 도킹할 수 있습니다. 이는 프레임의 가장자리에 대 한 도킹을 허용 하는 것 보다 더 많은 부동산을 필요로 하는 개체 브라우저 같은 큰 도구 창에 유용 합니다.

  ![Visual Studio의 도구 창 상태](../../extensibility/ux-guidelines/media/0702-01-toolwindowstates.png "0702-01_ToolWindowStates")

  **Visual Studio의 도구 창 상태**

#### <a name="single-instance-and-multi-instance"></a>단일 인스턴스 및 다중 인스턴스
 도구 창은 단일 인스턴스 또는 다중 인스턴스입니다. 일부 단일 인스턴스 도구 창은 활성 문서 창에 연결 되어 있을 수 있지만 다중 인스턴스 도구 창에는 연결 되지 않을 수 있습니다. 다중 인스턴스 도구 창은 창의 새 인스턴스를 만들어 창/새 창 명령에 응답 합니다. 다음 이미지는 창의 인스턴스가 활성화 될 때 새 창 명령을 사용 하도록 설정 하는 도구 창을 보여 줍니다.

 ![Visual Studio의 명령을 사용하는 도구 창](../../extensibility/ux-guidelines/media/0702-02-toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")

 **창 인스턴스가 활성화 되어 있을 때 ' 새 창 ' 명령을 사용 하는 도구 창**

 단일 인스턴스 도구 창은 숨겨지거나 표시 될 수 있지만, 다중 인스턴스 도구 창은 닫을 수도 있고 숨길 수도 있습니다. 모든 도구 창은 도킹, 탭 연결, 부동 또는 MDI (다중 문서 인터페이스) 자식 창 (문서 창과 유사)으로 설정할 수 있습니다. 모든 도구 창은 창 메뉴의 해당 창 관리 명령에 응답 해야 합니다.

 ![Visual Studio의 창 관리 명령](../../extensibility/ux-guidelines/media/0702-03-windowmanagementcontrols.png "0702-03_WindowManagementControls")

 **Visual Studio 창 메뉴의 창 관리 명령**

#### <a name="document-specific-tool-windows"></a>문서 특정 도구 창
 일부 도구 창은 지정 된 문서 형식에 따라 변경 되도록 설계 되었습니다. 이러한 창은 IDE의 활성 문서 창에 적용 되는 기능을 반영 하도록 지속적으로 업데이트 됩니다.

 선택한 편집기를 반영 하도록 내용이 변경 되는 도구 창의 예는 도구 상자와 문서 개요입니다. 이러한 창에는 창에 컨텍스트를 제공 하지 않는 포커스가 편집기에 있을 때 워터 마크가 표시 됩니다.

#### <a name="navigable-list-tool-windows"></a>탐색 가능한 목록 도구 창
 일부 도구 창에는 사용자가 조작할 수 있는 탐색 가능한 항목의 목록이 표시 됩니다. 이 유형의 창에는 창이 비활성 상태인 경우에도 목록의 현재 항목에 대 한 피드백이 항상 표시 됩니다. 이 목록은 창에서 현재 선택 된 항목을 변경 하 여 **GoToNextLocation** 및 **GoToPrevLocation** 명령에 응답 해야 합니다.

 탐색 가능한 목록 도구 창의 예는 솔루션 탐색기 및 찾기 결과 창입니다.

### <a name="tool-window-types"></a>도구 창 유형

#### <a name="common-tool-windows-and-their-functions"></a>일반 도구 창 및 해당 기능

|Type|도구 창|기능|
|----------|-----------------|--------------|
|**계층**|솔루션 탐색기|프로젝트, 기타 파일 및 솔루션 항목에 포함 된 문서 목록을 표시 하는 계층적 트리입니다. 프로젝트 내의 항목 표시는 프로젝트 형식 (예: 참조 기반, 디렉터리 기반 또는 혼합 모드 형식)을 소유 하는 패키지에 의해 정의 됩니다.|
|**계층**|클래스 뷰|파일 자체와 독립적인 클래스의 계층 구조 트리와 문서 작업 집합의 다양 한 요소입니다.|
|**계층**|서버 탐색기|솔루션의 모든 서버 및 데이터 연결을 표시 하는 계층적 트리입니다.|
|**계층**|문서 개요|활성 문서의 계층 구조입니다.|
|**눈금**|속성|선택 된 개체의 속성 목록과 함께 해당 속성을 편집 하는 값 선택 기가 표시 된 표입니다.|
|**눈금**|작업 목록|사용자가 작업 및 주석을 만들거나 편집/삭제할 수 있는 그리드입니다.|
|**콘텐츠**|도움말|사용자가 "어떻게 할까요?"에서 도움을 얻을 수 있는 다양 한 방법에 액세스할 수 있도록 하는 창입니다. MSDN 포럼 비디오.|
|**콘텐츠**|동적 도움말|현재 선택 영역에 적용할 수 있는 도움말 항목에 대 한 링크를 표시 하는 도구 창입니다.|
|**콘텐츠**|개체 브라우저|왼쪽 창에 계층적 개체 구성 요소 목록과 오른쪽 열에 있는 개체의 속성 및 메서드를 포함 하는 두 개의 열로 구성 된 프레임셋|
|**대화 상자**|찾기, 고급 찾기|사용자가 솔루션 내에서 다양 한 파일을 찾거나 바꿀 수 있는 대화 상자입니다.|
|**기타**|도구 상자|디자인 화면에 끌어 놓을 요소를 저장 하는 데 사용 되는 도구 창으로, 모든 디자이너에 대해 일관 된 끌기 소스를 제공 합니다.|
|**기타**|시작 페이지|개발자 뉴스, Visual Studio 도움말 및 최근 프로젝트의 피드에 액세스할 수 있는 Visual Studio에 대 한 사용자 포털입니다. 사용자는 "Common7\IDE\StartPages\" Visual Studio program files 디렉터리에서 Visual Studio documents 디렉터리의 StartPages 폴더로 StartPage 파일을 복사 하 여 사용자 지정 시작 페이지를 만든 다음, XAML을 직접 편집 하거나 Visual Studio 또는 다른 코드 편집기에서 열어 사용자 지정 시작 페이지를 만들 수도 있습니다.|
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|자동||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|직접 실행||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|출력|텍스트 이벤트 나 상태를 선언할 때마다 출력 창을 사용할 수 있습니다.|
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|메모리||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|중단점||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|실행 중||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|문서||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|호출 스택||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|로컬||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|조사||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|디스어셈블리||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|레지스터||
|**디버거:** 디버깅 작업 및 모니터링 작업과 관련 된 windows 그룹입니다.|스레드||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>문서 편집기 규칙

### <a name="document-interactions"></a>문서 상호 작용
 "문서 웰"은 IDE 내에서 가장 큰 공간으로, 사용자가 일반적으로 해당 작업을 완료 하기 위해 사용자가 관심을 갖고 있으며,이는 추가 도구 창에 의해 지원 됩니다. 문서 편집기는 사용자가 Visual Studio 내에서 열고 저장 하는 기본 작업 단위를 나타냅니다. 솔루션 탐색기 또는 다른 활성 계층 창에 연결 된 선택 항목의 강력한 의미를 유지 합니다. 사용자는 이러한 계층 구조 창 중 하나를 가리켜 해당 문서가 포함 된 위치 및 Visual Studio 패키지에서 제공 하는 솔루션, 프로젝트 또는 다른 루트 개체와의 관계를 확인할 수 있어야 합니다.

 문서를 편집 하려면 일관적인 사용자 환경이 필요 합니다. 사용자가 창 관리가 아닌 작업에 집중 하 고 명령을 찾는 것을 허용 하려면 해당 문서 유형을 편집 하기 위한 사용자 작업에 가장 잘 맞는 문서 보기 전략을 선택 합니다.

#### <a name="common-interactions-for-the-document-well"></a>문서 웰의 일반적인 상호 작용

- 일반적인 **새 파일** 및 **오픈 파일** 환경에서 일관 된 상호 작용 모델을 유지 합니다.

- 문서 창이 열릴 때 관련 창 및 메뉴의 관련 기능을 업데이트 합니다.

- 메뉴 명령은 **편집**, **서식**및 **보기** 메뉴와 같은 일반적인 메뉴에 적절 하 게 통합 됩니다. 매우 많은 특수 한 명령을 사용할 수 있는 경우 문서에 포커스가 있을 때만 표시 되는 새 메뉴를 만들 수 있습니다.

- 포함 된 도구 모음은 편집기의 맨 위에 배치 될 수 있습니다. 편집기 외부에 표시 되는 별도의 도구 모음을 포함 하는 것이 좋습니다.

- 항상 솔루션 탐색기 또는 유사한 활성 계층 창에서 선택 항목을 유지 합니다.

- 솔루션 탐색기에서 문서를 두 번 클릭 하면 **열기**와 같은 작업을 수행 해야 합니다.

- 문서 유형에 둘 이상의 편집기를 사용할 수 있는 경우 사용자는 해당 파일을 마우스 오른쪽 단추로 클릭 하 고 바로 가기 메뉴에서 **연결 프로그램** 을 선택 하 여 **연결 프로그램** 대화 상자를 사용 하 여 지정 된 문서 유형에 대 한 기본 동작을 재정의 하거나 다시 설정할 수 있어야 합니다.

- 문서 웰에서 마법사를 빌드하지 않습니다.

### <a name="user-expectations-for-specific-document-types"></a>특정 문서 유형에 대 한 사용자의 기대
 문서 편집기의 기본 형식에는 여러 가지가 있으며, 각 형식에는 동일한 유형의 다른 사용자와 일치 하는 상호 작용 집합이 있습니다.

- **텍스트 기반 편집기:** 코드 편집기, 로그 파일

- **디자인 화면:** WPF 폼 디자이너, Windows forms

- **대화 상자 스타일 편집기:** 매니페스트 디자이너, 프로젝트 속성

- **모델 디자이너:** 워크플로 디자이너, codemap, 아키텍처 다이어그램, 진행

  또한 문서 웰을 사용 하는 여러 가지 비 편집기 형식도 있습니다. 문서 자체를 편집 하지는 않지만 문서 창에 대 한 표준 상호 작용을 수행 해야 합니다.

- **보고서:** IntelliTrace 보고서, Hyper-v 보고서, 프로파일러 보고서

- **대시보드:** 진단 허브

#### <a name="text-based-editors"></a>텍스트 기반 편집기

- 문서는 미리 보기 탭 모델에 참여 하므로 문서를 열지 않고도 미리 볼 수 있습니다.

- 문서 구조는 문서 개요와 같은 도우미 도구 창에 표시 될 수 있습니다.

- IntelliSense (해당 하는 경우)는 다른 코드 편집기와 일관 되 게 동작 합니다.

- 팝업 또는 보조 UI는 CodeLens와 같은 기존의 비슷한 UI에 대해 비슷한 스타일 및 패턴을 따릅니다.

- 문서 상태와 관련 된 메시지는 문서 맨 위에 있는 정보 표시줄 컨트롤이 나 상태 표시줄에 표시 됩니다.

- 사용자는 **도구 > 옵션** 페이지, 공유 글꼴 및 색 페이지 또는 편집기에 특정 한 도구를 사용 하 여 글꼴 및 색의 모양을 사용자 지정할 수 있어야 합니다.

#### <a name="design-surfaces"></a>디자인 화면

- 빈 디자이너는 시작 방법을 나타내는 워터 마크를 화면에 포함 해야 합니다.

- 뷰 전환 메커니즘은 두 번 클릭 하 여 코드 편집기를 열거나 두 창에서 상호 작용할 수 있는 문서 창 내의 탭과 같은 기존 패턴을 따릅니다.

- 매우 구체적인 도구 창이 필요한 경우를 제외 하 고 디자인 화면에 요소를 추가 하려면 도구 상자를 통해 수행 해야 합니다.

- 화면의 항목은 일관 된 선택 모델을 따릅니다.

- 포함 된 도구 모음에는 **저장**과 같은 일반적인 명령이 아닌 문서 관련 명령만 포함 됩니다.

#### <a name="dialog-style-editors"></a>대화 상자 스타일 편집기

- 컨트롤 레이아웃은 일반 대화 상자 레이아웃 규칙을 따라야 합니다.

- 편집기 내의 탭은 문서 탭의 모양과 일치 하지 않아야 하며 두 개의 허용 된 내부 탭 스타일 중 하 나와 일치 해야 합니다.

- 사용자는 키보드를 사용 하 여 컨트롤과 상호 작용할 수 있어야 합니다. 편집기를 활성화 하 고 컨트롤을 사용 하거나 표준 니모닉을 사용 하 여 탭 이동 합니다.

- 디자이너에서 일반적인 저장 모델을 사용 해야 합니다. 다른 단추가 적합할 수도 있지만 전체 저장 또는 커밋 단추가 화면에 배치 되는 것은 아닙니다.

#### <a name="model-designers"></a>모델 디자이너

- 빈 디자이너는 시작 방법을 나타내는 워터 마크를 화면에 포함 해야 합니다.

- 디자인 화면에 요소를 추가 하려면 도구 상자를 통해 수행 해야 합니다.

- 화면의 항목은 일관 된 선택 모델을 따릅니다.

- 포함 된 도구 모음에는 **저장**과 같은 일반적인 명령이 아닌 문서 관련 명령만 포함 됩니다.

- 범례는 표시 또는 워터 마크 중 하나에 표시 될 수 있습니다.

- 사용자는 **도구 > 옵션** 페이지, 공유 글꼴 및 색 페이지 또는 편집기에 특정 한 도구를 사용 하 여 글꼴/색의 모양을 사용자 지정할 수 있어야 합니다.

#### <a name="reports"></a>보고서

- 보고서는 일반적으로 정보를 포함 하며 저장 모델에 참여 하지 않습니다. 그러나 확장 및 축소 하는 다른 관련 정보 또는 섹션에 대 한 링크와 같은 상호 작용을 포함할 수 있습니다.

- 화면에서 대부분의 명령은 단추가 아니라 하이퍼링크 여야 합니다.

- 레이아웃에는 머리글을 포함 하 고 표준 보고서 레이아웃 지침을 따라야 합니다.

#### <a name="dashboards"></a>대시보드

- 대시보드는 상호 작용 모델 자체를 갖지 않지만 다양 한 다른 도구를 제공 하는 수단으로 사용할 수 있습니다.

- 저장 모델에 참여 하지 않습니다.

- 사용자는 편집기를 활성화 하 고 컨트롤을 통해 탭 하거나 표준 니모닉을 사용 하 여 키보드를 사용 하 여 컨트롤과 상호 작용할 수 있어야 합니다.

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a>상자로

### <a name="introduction"></a>소개
 Visual Studio의 대화 상자는 일반적으로 사용자 작업의 불연속 단위를 하나 지원 하 고 해제할 수 있습니다.

 대화 상자가 필요 하다 고 판단 되 면 다음과 같은 세 가지 옵션을 선택할 수 있습니다.

1. Visual Studio의 공유 대화 상자 중 하나에 기능을 통합 합니다.

2. 유사한 기존 대화 상자에서 발견 된 패턴을 사용 하 여 사용자 고유의 대화 상자를 만듭니다.

3. 상호 작용 및 레이아웃 지침에 따라 새 대화 상자를 만듭니다.

   이 항목에서는 Visual Studio 워크플로 내에서 올바른 대화 상자 패턴을 선택 하는 방법과 대화 상자를 디자인 하는 일반적인 규칙에 대해 설명 합니다.

### <a name="themes"></a>테마
 Visual Studio의 대화 상자는 다음 두 가지 기본 스타일 중 하나를 따릅니다.

#### <a name="standard-unthemed"></a>표준 (테마가 적용 되지 않음)
 대부분의 대화 상자는 표준 유틸리티 대화 상자 이며 테마를 적용할 수 없습니다. 공용 컨트롤의 템플릿을 다시 작성 하거나 스타일이 있는 "최신" 단추나 컨트롤을 만들지 마십시오. 컨트롤 및 chrome 모양은 [대화 상자에 대 한 표준 Windows 바탕 화면 상호 작용 지침을](https://msdn.microsoft.com/library/windows/desktop/dn742499\(v=vs.85\).aspx)따릅니다.

#### <a name="themed"></a>테마
 특수 "서명" 대화 상자에 테마를 적용할 수 있습니다. 테마가 적용 된 대화 상자에는 스타일과 연결 된 특수 한 상호 작용 패턴이 있는 고유한 모양이 있습니다. 다음 요구 사항을 충족 하는 경우에만 대화 상자에 테마를 적용 합니다.

- 이 대화 상자는 자주 또는 대부분의 사용자 (예: **새 프로젝트** 대화 상자)에서 표시 되 고 사용 되는 일반적인 환경입니다.

- 대화 상자에는 주요 제품 브랜드 요소 (예: **계정 설정** 대화 상자)가 포함 되어 있습니다.

- 대화 상자는 다른 테마가 적용 된 대화 상자 (예: **연결 된 서비스 추가** 대화 상자)를 포함 하는 더 큰 흐름의 정수 부분으로 나타납니다.

- 이 대화 상자는 제품 버전을 홍보 하거나 차별화 하기 위해 전략적 역할을 수행 하는 환경에서 중요 한 부분입니다.

  테마 대화 상자를 만들 때 적절 한 환경 색을 사용 하 고 올바른 레이아웃 및 상호 작용 패턴을 따릅니다. ( [Visual Studio의 레이아웃](../../extensibility/ux-guidelines/layout-for-visual-studio.md)참조)

### <a name="dialog-design"></a>대화 상자 디자인
 잘 디자인 된 대화 상자에서는 다음 요소를 고려해 야 합니다.

- 지원 되는 사용자 작업

- 대화 상자 텍스트 스타일, 언어 및 용어

- 컨트롤 선택 및 UI 규칙

- 시각적 레이아웃 사양 및 컨트롤 맞춤

- 키보드 액세스

#### <a name="content-organization"></a>콘텐츠 구성
 이러한 기본 대화 형식 간의 차이점을 고려 합니다.

- [간단한 대화 상자](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 는 단일 모달 창에 컨트롤을 제공 합니다. 이 프레젠테이션에는 필드 선택 또는 아이콘 막대를 포함 하 여 복잡 한 컨트롤 패턴의 변형이 포함 될 수 있습니다.

- 단일 UI가 여러 컨트롤 그룹으로 구성 된 경우 [계층화 된 대화 상자](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs) 는 화면 부동산을 최대한 활용 하는 데 사용 됩니다. 대화 상자의 그룹화는 탭 컨트롤, 탐색 목록 컨트롤 또는 단추를 통해 "계층화" 되므로 사용자가 지정 된 순간에 볼 그룹화를 선택할 수 있습니다.

- [마법사](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) 는 작업 완료에 대 한 논리적 단계 시퀀스를 통해 사용자를 전달 하는 데 유용 합니다. 일련의 선택 항목이 순차 패널에 제공 되며, 경우에 따라 이전 패널에서 선택한 항목에 따라 다른 워크플로 ("분기")가 도입 됩니다.

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>간단한 대화 상자
 간단한 대화 상자는 단일 모달 창에 컨트롤을 표시 하는 것입니다. 이 프레젠테이션에는 필드 선택기와 같은 복잡 한 컨트롤 패턴의 변형이 포함 될 수 있습니다. 간단한 대화 상자에서는 표준 일반 레이아웃 뿐만 아니라 복잡 한 컨트롤 그룹화에 필요한 특정 레이아웃을 따릅니다.

 ![Visual Studio의 간단한 대화 상자](../../extensibility/ux-guidelines/media/0704-01-createstrongnamekey.png "0704-01_CreateStrongNameKey")

 **강력한 이름 키 만들기는 Visual Studio의 간단한 대화 상자 예제입니다.**

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>계층화 된 대화 상자
 계층화 된 대화 상자에는 탭, 대시보드 및 포함 된 트리가 있습니다. 단일 UI에서 제공 되는 여러 컨트롤 그룹이 있는 경우 부동산을 최대화 하는 데 사용 됩니다. 사용자가 한 번에 볼 그룹화를 선택할 수 있도록 그룹화가 계층화 됩니다.

 가장 간단한 경우 그룹 간을 전환 하는 메커니즘은 탭 컨트롤입니다. 사용할 수 있는 여러 가지 대안이 있습니다. 가장 적절 한 스타일을 선택 하는 방법은 우선 순위 및 계층화를 참조 하세요.

 **도구 > 옵션** 대화 상자는 포함 된 트리를 사용 하는 계층화 된 대화 상자의 예입니다.

 ![Visual Studio의 계층화된 대화 상자](../../extensibility/ux-guidelines/media/0704-02-toolsoptions.png "0704-02_ToolsOptions")

 **도구 > 옵션은 Visual Studio의 계층화 된 대화 상자 예제입니다.**

#### <a name="wizards"></a><a name="BKMK_Wizards"></a>마법사로
 마법사는 태스크 완료 시 논리적 단계 시퀀스를 통해 사용자를 전달 하는 데 유용 합니다. 일련의 선택 항목이 순차 패널에 제공 되며, 사용자는 다음 단계를 진행 하기 전에 각 단계를 계속 진행 해야 합니다. 충분 한 기본값을 사용할 수 있게 되 면 **마침** 단추를 사용할 수 있습니다.

 모달 마법사는 다음과 같은 작업에 사용 됩니다.

- 사용자 선택에 따라 서로 다른 경로가 제공 되는 분기를 포함 합니다.

- 단계 간의 종속성을 포함 합니다 .이 단계에서 후속 단계는 이전 단계의 사용자 입력에 따라 달라 집니다.

- UI를 사용 하 여 제공 된 선택 항목을 설명 하 고 각 단계에서 가능한 결과를 설명 하는 데 충분 합니다.

- 트랜잭션이 며 변경 내용을 커밋하기 전에 전체 단계를 완료 해야 합니다.

### <a name="common-conventions"></a>일반 규칙
 대화 상자에서 최적의 디자인 및 기능을 사용 하려면 대화 상자 크기, 위치, 표준, 컨트롤 구성 및 맞춤, UI 텍스트, 제목 표시줄, 컨트롤 단추 및 액세스 키에 대 한 규칙을 따릅니다.

 레이아웃 관련 지침은 [Visual Studio의 레이아웃](../../extensibility/ux-guidelines/layout-for-visual-studio.md)을 참조 하세요.

#### <a name="size"></a>크기
 대화는 최소 1024x768 화면 해상도 내에 있어야 하 고 초기 대화 상자 크기는 900x700 픽셀을 초과 하면 안 됩니다. 대화 상자는 크기를 조정할 수 있지만 반드시 필요한 것은 아닙니다.

 크기 조정 가능한 대화 상자에는 다음과 같은 두 가지 권장 사항이 있습니다.

1. 최소 크기는 클리핑 하지 않고 컨트롤 집합을 최적화 하는 대화 상자에 대해 정의 된이 고 적절 한 지역화 증가를 수용 하기 위해 조정 됩니다.

2. 사용자 크기 조정 된 크기가 세션에서 세션으로 유지 됩니다. 예를 들어 사용자가 대화 상자를 150%로 조정 하면 대화 상자의 다음 시작이 150%로 표시 됩니다.

#### <a name="position"></a>위치
 대화는 처음 시작할 때 IDE 내에서 가운데에 표시 되어야 합니다. 크기를 조정할 수 없는 대화의 경우 대화 상자의 마지막 위치를 유지 하는 것이 필요 하지 않으므로 후속 시작의 중앙에 표시 됩니다. 크기 조정 가능한 대화 상자의 경우에는 이후 시작 시 크기가 유지 됩니다. 모달 인 크기 조정 가능한 대화의 경우 위치를 지속할 필요가 없습니다. IDE 내에서 가운데에 표시 하면 사용자의 표시 구성이 변경 될 때 예기치 않거나 사용할 수 없는 위치에 대화가 나타날 가능성이 없습니다. 위치를 변경할 수 있는 모덜리스 대화의 경우 대화가 더 큰 워크플로의 필수적인 부분으로 자주 사용 될 수 있으므로 사용자의 위치는 후속 시작 시 유지 되어야 합니다.

 대화 상자에서 다른 대화 상자를 생성 해야 하는 경우 사용자에 게 새 위치로 탐색 하는 것을 명확 하 게 하기 위해 맨 위 대화 상자는 부모에서 오른쪽 및 아래쪽으로 계단식으로 배열 되어야 합니다.

#### <a name="modality"></a>모달
 모달은 계속 하기 전에 사용자가 대화 상자를 완료 하거나 취소 해야 함을 의미 합니다. 모달 대화 상자는 사용자가 환경의 다른 부분과 상호 작용 하는 것을 차단 하므로 기능 작업 흐름은 최대한 가급적 사용 해야 합니다. 모달 작업이 필요한 경우 Visual Studio에는 기능을 통합 하는 데 사용할 수 있는 여러 공유 대화 상자가 있습니다. 새 대화 상자를 만들어야 하는 경우 유사한 기능을 사용 하 여 기존 대화의 상호 작용 패턴을 따릅니다.

 사용자가 새 코드를 작성 하는 동안 **찾기** 및 **바꾸기** 와 같이 두 개의 활동을 한 번에 수행 해야 하는 경우에는 사용자가 해당 대화 상자를 쉽게 전환할 수 있도록 모덜리스가 되어야 합니다. Visual Studio에서는 일반적으로 이러한 종류의 편집기 지원 연결 된 작업에 대해 도구 창을 사용 합니다.

#### <a name="control-configuration"></a>구성 제어
 Visual Studio에서 동일한 작업을 수행 하는 기존 컨트롤 구성과 일치 해야 합니다.

#### <a name="title-bars"></a>제목 표시줄

- 제목 표시줄의 텍스트는 해당 텍스트를 시작한 명령의 이름을 반영 해야 합니다.

- 대화 상자 제목 표시줄에는 아이콘을 사용 하지 않아야 합니다. 시스템에 필요한 경우 Visual Studio 로고를 사용 합니다.

- 대화 상자에 최소화 또는 최대화 단추가 없어야 합니다.

- 제목 표시줄의 도움말 단추는 더 이상 사용 되지 않습니다. 새 대화 상자에 추가 하지 마세요. 이러한 항목이 있으면 작업에 개념적으로 관련 된 도움말 항목을 시작 해야 합니다.

  ![Visual Studio의 제목 표시줄 사양](../../extensibility/ux-guidelines/media/0704-03-titlebarspecs.png "0704-03_TitleBarSpecs")

  **Visual Studio 대화 상자의 제목 표시줄에 대 한 지침 사양입니다.**

#### <a name="control-buttons"></a>컨트롤 단추
 일반적으로 **확인** / **취소** / **도움말** 단추는 대화 상자의 오른쪽 아래 모서리에 가로로 정렬 되어야 합니다. 대화 상자 아래쪽에 컨트롤 단추와의 시각적 혼동을 주는 다른 단추가 대화 상자에 있는 경우 대체 세로 스택이 허용 됩니다.

 ![Visual Studio의 컨트롤 단추 구성](../../extensibility/ux-guidelines/media/0704-04-controlbuttonconfig.png "0704-04_ControlButtonConfig")

 **Visual Studio 대화 상자의 컨트롤 단추에 대해 허용 되는 구성**

 대화 상자에는 기본 컨트롤 단추가 포함 되어야 합니다. 기본값으로 사용할 가장 좋은 명령을 결정 하려면 다음 옵션 중에서 선택 합니다 (우선 순위에 따라 나열 됨).

- 가장 안전 하 고 가장 안전한 명령을 기본값으로 선택 합니다. 즉, 데이터 손실을 방지 하 고 의도 하지 않은 시스템 액세스를 방지할 가능성이 가장 높은 명령을 선택 합니다.

- 데이터 손실 및 보안이 요인이 아닌 경우 편의를 기준으로 기본 명령을 선택 합니다. 가장 가능성이 높은 명령을 기본값으로 포함 하면 대화에서 자주 또는 반복적인 작업을 지 원하는 경우 사용자의 워크플로가 향상 됩니다.

  기본 명령에 대해 영구적으로 파괴적인 작업을 선택 하지 마십시오. 이러한 명령이 있는 경우 대신 안전한 명령을 기본값으로 선택 합니다.

#### <a name="access-keys"></a>액세스 키
 **확인** / **취소** / **도움말** 단추에 대 한 액세스 키를 사용 하지 마십시오. 이러한 단추는 기본적으로 바로 가기 키에 매핑됩니다.

|단추 이름|키보드 바로 가기 키|
|-----------------|-----------------------|
|정상|Enter|
|취소|Esc|
|도움말|F1|

#### <a name="imagery"></a>이미지
 대화 상자에서 이미지를 사용 하는 경우에만 사용 합니다. 단지 공간을 사용 하기 위해 대화 상자에서 긴 아이콘을 사용 하지 마십시오. 경고 아이콘 또는 상태 애니메이션과 같이 사용자에 게 메시지를 전달 하는 데 중요 한 부분인 경우에만 이미지를 사용 합니다.

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>우선 순위 및 계층화

#### <a name="prioritizing-your-ui"></a>UI 우선 순위 결정
 Forefront에 특정 UI 요소를 가져오고 대화 상자에 고급 동작 및 옵션 (모호한 명령 포함)을 추가 해야 할 수도 있습니다. 일반적으로 사용 되는 기능을 사용할 수 있도록 설정 하 고, 대화 상자가 표시 될 때 UI에 기본적으로 표시 되는 텍스트 레이블이 있는 기능을 만듭니다.

#### <a name="layering-your-ui"></a>UI 계층화
 대화 상자가 필요 하지만 사용자에 게 표시 하려는 관련 기능이 간단한 대화 상자에 표시 될 수 있는 것 보다 많은 경우 UI를 계층화 해야 합니다. Visual Studio에서 사용 하는 가장 일반적인 계층화 메서드는 탭과 hallways 또는 대시보드입니다. 경우에 따라 확장 및 축소할 수 있는 지역이 적절할 수 있습니다. 적응 UI는 일반적으로 Visual Studio에서 권장 되지 않습니다.

 탭과 같은 컨트롤을 통해 UI를 계층화 하는 여러 방법에는 장단점이 있습니다. 아래 목록을 검토 하 여 상황에 적합 한 계층화 기법을 선택 하 고 있는지 확인 하십시오.

##### <a name="tabbing"></a>탭 이동

|전환 메커니즘|장점과 적절 한 사용|단점 및 부적절 한 사용|
|-------------------------|------------------------------------|-----------------------------------------|
|탭 컨트롤|대화 상자 페이지를 관련 집합으로 논리적으로 그룹화<br /><br /> 대화 상자에 있는 관련 컨트롤의 페이지 수 (또는 대화 상자에서 한 행에 맞는 탭 수) 보다 작은 경우에 유용 합니다.<br /><br /> 콘텐츠를 쉽게 식별할 수 있는 하나 또는 두 개의 단어로 된 탭 레이블은 짧아야 합니다.<br /><br /> 공통 시스템 대화 상자 스타일<br /><br /> 예: **파일 탐색기 > 항목 속성**|설명이 포함 된 짧은 레이블을 만드는 것이 어려울 수 있습니다.<br /><br /> 일반적으로 한 대화 상자에서 5 개의 탭을 벗어나 확장 되지 않습니다.<br /><br /> 한 행에 너무 많은 탭이 있으면 부적합 합니다. 대체 계층화 기술 사용<br /><br /> 확장할 수 없음|
|사이드바 탐색|탭 보다 많은 범주를 수용할 수 있는 간단한 전환 장치<br /><br /> 범주의 단순 목록 (계층 없음)<br /><br /> 확장 가능<br /><br /> 예: **사용자 지정 ... > Add 명령**|그룹이 세 개 미만이 면 가로 공간을 사용 하지 않는 것이 좋습니다.<br /><br /> 작업은 드롭다운에 보다 적합할 수 있습니다.|
|트리 컨트롤|무제한 범주 허용<br /><br /> 범주 그룹 및/또는 계층 구조를 허용 합니다.<br /><br /> 확장 가능<br /><br /> 예: **도구 > 옵션**|과도 하 게 중첩 된 계층은 과도 한 스크롤을 발생 시킬 수 있습니다.<br /><br /> Visual Studio에는 트리 뷰가 과도 하 게 포함 되어 있습니다.|
|마법사|작업을 완료 하는 과정을 안내 하는 작업을 지원 합니다. 마법사는 상위 수준 작업을 나타내며 개별 패널은 전체 작업을 수행 하는 데 필요한 하위 작업을 나타냅니다.<br /><br /> 사용자가 여러 편집기 및 도구 창을 사용 하 여 작업을 완료 해야 하는 경우와 같이 작업이 Ui 경계를 교차할 때 유용 합니다.<br /><br /> 작업에서 분기가 필요한 경우에 유용 합니다.<br /><br /> 태스크에 단계 간 종속성이 포함 된 경우에 유용 합니다.<br /><br /> 한 가지 결정 포크를 사용 하는 비슷한 여러 작업을 하나의 대화 상자에 표시 하 여 비슷한 대화 상자 수를 줄일 수 있는 경우 유용 합니다.|순차 워크플로가 필요 하지 않은 작업에 적합 하지 않음<br /><br /> 사용자가 너무 많은 단계가 있는 마법사에 의해 과도 하 게 혼란 스 러 울 수 있습니다.<br /><br /> 기본적으로 제한 된 화면 부동산|

##### <a name="hallways-or-dashboards"></a>Hallways 또는 대시보드
 Hallways 및 대시보드는 다른 대화 상자 및 창에 대 한 시작 지점의 역할을 하는 대화 상자 또는 패널입니다. 잘 디자인 된 "복도"는 사용자가 일반적인 작업을 쉽게 수행할 수 있도록 가장 일반적인 옵션, 명령 및 설정만을 즉시 표시 합니다. 실제 복도는 실제 지역에 액세스할 수 있는 doorways를 제공 합니다. 여기에서 덜 일반적인 UI는 주 복도에서 액세스할 수 있는 관련 기능의 개별 "방" (종종 다른 대화 상자)로 수집 됩니다.

 또는 일반 기능을 별도의 위치로 리팩터링 하는 대신 단일 컬렉션에서 사용할 수 있는 모든 기능을 제공 하는 UI는 단순한 대시보드입니다.

 ![Outlook의 복도(Hallway) 개념](../../extensibility/ux-guidelines/media/0704-08-hallway.png "0704-08_Hallway")

 **Outlook에서 추가 UI를 노출 하는 복도 개념**

##### <a name="adaptive-ui"></a>적응 UI
 사용량을 기준으로 UI를 표시 하거나 숨기 거 나 사용자의 자체 보고 된 환경을 숨기는 것은 다른 부분을 숨기는 동시에 필요한 UI를 표시 하는 또 다른 방법입니다. 이는 UI를 표시 하거나 숨기는 시기를 결정 하는 알고리즘을 결정 하는 알고리즘을 사용할 수 없기 때문에 Visual Studio에서 권장 되지 않습니다. 규칙은 일부 사례 집합에 대해 항상 잘못 된 것입니다.

## <a name="projects"></a><a name="BKMK_Projects"></a>프로젝트

### <a name="projects-in-the-solution-explorer"></a>솔루션 탐색기의 프로젝트
 대부분의 프로젝트는 참조 기반, 디렉터리 기반 또는 혼합으로 분류 됩니다. 이 세 가지 유형의 프로젝트는 모두 솔루션 탐색기에서 동시에 지원 됩니다. 프로젝트 작업의 사용자 환경 루트는이 창 내에서 발생 합니다. 서로 다른 프로젝트 노드가 참조, 디렉터리 또는 혼합 모드 형식 프로젝트 이지만 프로젝트 관련 사용자 패턴으로 분기 하기 전에 시작 지점으로 적용 해야 하는 일반적인 상호 작용 패턴이 있습니다.

 프로젝트는 항상 다음과 같아야 합니다.

- 프로젝트 콘텐츠를 구성 하는 프로젝트 폴더를 추가 하는 기능 지원

- 프로젝트 지 속성을 위한 일관 된 모델 유지 관리

  또한 프로젝트는 다음에 대 한 일관성 있는 상호 작용 모델을 유지 해야 합니다.

- 프로젝트 항목 제거

- 문서 저장

- 프로젝트 속성 편집

- 대체 뷰에서 프로젝트 편집

- 끌어서 놓기 작업

### <a name="drag-and-drop-interaction-model"></a>끌어서 놓기 상호 작용 모델
 프로젝트는 일반적으로 참조 기반 (저장소의 프로젝트 항목에 대 한 참조만 유지할 수 있음), 디렉터리 기반 (프로젝트의 계층 구조에 실제로 저장 된 프로젝트 항목만 보관할 수 있음) 또는 혼합 (참조 또는 실제 항목을 유지할 수 있음)으로 분류 됩니다. IDE는 **솔루션 탐색기**내에서 세 가지 형식의 프로젝트를 동시에 모두 수용 합니다.

 끌어서 놓기 관점에서 다음과 같은 특징이 **솔루션 탐색기**내의 각 프로젝트 형식에 적용 되어야 합니다.

- **참조 기반 프로젝트:** 핵심 점은 프로젝트가 저장소의 항목에 대 한 참조를 끄는 것입니다. 참조 기반 프로젝트가 이동 작업의 소스로 사용 되는 경우 프로젝트에서 항목에 대 한 참조만 제거 해야 합니다. 실제로 하드 드라이브에서 항목을 삭제 해서는 안 됩니다. 참조 기반 프로젝트가 이동 (또는 복사) 작업의 대상 역할을 하는 경우 항목의 전용 복사본을 만들지 않고 원래 소스 항목에 대 한 참조를 추가 해야 합니다.

- **디렉터리 기반 프로젝트:** 끌어서 놓기 관점에서 볼 때 프로젝트는 참조가 아니라 물리적 항목 주위에서 끌고 있습니다. 디렉터리 기반 프로젝트가 이동 작업의 원본 역할을 하는 경우 하드 드라이브에서 실제 항목을 삭제 하 고 프로젝트에서 제거 해야 합니다. 디렉터리 기반 프로젝트가 이동 (또는 복사) 작업의 대상 역할을 하는 경우 대상 위치에 원본 항목의 복사본을 만들어야 합니다.

- **혼합 대상 프로젝트:** 끌어서 놓기 관점에서이 프로젝트 형식의 동작은 끌어 온 항목의 특성 (저장소 또는 항목 자체에 대 한 참조)을 기반으로 합니다. 참조 및 실제 항목에 대 한 올바른 동작은 위에 설명 되어 있습니다.

  **솔루션 탐색기**에 프로젝트 형식이 하나만 있는 경우 끌어서 놓기 작업은 간단 합니다. 각 프로젝트 시스템에는 자체 끌어서 놓기 동작을 정의할 수 있는 기능이 있기 때문에 예측 가능한 사용자 환경을 보장 하려면 Windows 탐색기 끌어서 놓기 동작을 기반으로 하는 특정 지침을 따라야 합니다.

- **솔루션 탐색기** 에서 수정 되지 않은 끌기 작업 (Ctrl 또는 Shift 키를 누르고 있지 않은 경우)은 이동 작업을 수행 해야 합니다.

- Shift + 끌기 작업을 수행 하면 이동 작업도 수행 됩니다.

- Ctrl + 끌기 작업으로 인해 복사 작업이 수행 됩니다.

- 참조 기반 및 혼합 프로젝트 시스템은 소스 항목에 대 한 링크 (또는 참조)를 추가 하는 개념을 지원 합니다. 이러한 프로젝트가 끌어서 놓기 작업의 대상인 경우 ( **Ctrl + Shift** 가 중단 되 면) 프로젝트에 추가 되는 항목에 대 한 참조가 발생 해야 합니다.

  모든 끌어서 놓기 작업은 참조 기반 디렉터리 기반 및 혼합 프로젝트의 조합에서 적절 하지 않습니다. 특히 원본 디렉터리 기반 프로젝트는 이동 완료 시 소스 항목을 삭제 해야 하기 때문에 디렉터리 기반 소스 프로젝트와 참조 기반 대상 프로젝트 간에 이동 작업을 허용 하는 것이 좋습니다. 그러면 대상 참조 기반 프로젝트가 삭제 된 항목에 대 한 참조로 종료 됩니다.

  대상 참조 기반 프로젝트가 소스 항목의 독립적인 복사본을 만들지 않아야 하므로 이러한 형식의 프로젝트 간에 복사 작업을 허용 하는 것은 잘못 된 것입니다. 마찬가지로, 디렉터리 기반 프로젝트에서 참조를 유지할 수 없으므로 Ctrl + Shift를 디렉터리 기반 대상 프로젝트로 끌어 올 수 없습니다. 끌어서 놓기 작업이 지원 되지 않는 경우에는 IDE에서 drop을 허용 하지 않고 사용자에 게 드롭 안 함 커서를 표시 합니다 (아래 포인터 표에 표시 됨).

  끌어서 놓기 동작을 제대로 구현 하려면 끌기의 원본 프로젝트에서 대상 프로젝트에 대 한 특성 (예: 참조 또는 디렉터리 기반?)을 전달 해야 합니다. 이 정보는 원본에서 제공 하는 클립보드 형식으로 표시 됩니다. 끌기 (또는 클립보드 복사 작업)의 소스로 프로젝트는 프로젝트가 참조 기반 인지 아니면 디렉터리 기반 인지에 따라 각각 **CF_VSREFPROJECTITEM**S 또는 **CF_VSSTGPROJECTITEMS** 를 제공 해야 합니다. 이러한 형식에는 모두 동일한 데이터 **CF_HDROP** 내용이 포함 되며,이는 파일 이름이 아닌 문자열 목록이 **Projref** 문자열의 이중**NULL** 종료 목록 (적절 하 게 **Ivssolution:: GetProjrefOfItem** 또는 **:: GetProjrefOfProject** 에서 반환 됨)입니다.

  끌어서 놓기 작업을 정확 하 게 처리 하는 작업은 대상 프로젝트와 소스 프로젝트의 특성에 따라 달라 지지만, drop (또는 클립보드 붙여넣기 작업)의 대상으로 **CF_VSREFPROJECTITEMS** 와 **CF_VSSTGPROJECTITEMS**를 모두 수락 해야 합니다. 원본 프로젝트는 **CF_VSREFPROJECTITEMS** 또는 **CF_VSSTGPROJECTITEMS**를 제공 하는지 여부에 따라 특성을 선언 합니다. Drop의 대상은 고유한 특성을 이해 하므로 이동, 복사 또는 링크를 수행 해야 하는지 여부에 따라 결정을 내리는 데 충분 한 정보가 있습니다. 또한 ctrl, Shift 또는 Ctrl 키와 Shift 키를 눌러 수행 해야 하는 끌어서 놓기 작업을 수정 합니다. 놓기 대상에서 **system.windows.dragdrop.dragenter>** 및 **system.windows.uielement.dragover>** 메서드를 통해 미리 수행 될 작업을 올바르게 표시 하는 것이 중요 합니다. **솔루션 탐색기** 소스 프로젝트와 대상 프로젝트가 동일한 프로젝트 인지 여부를 자동으로 알 수 있습니다.

  Visual Studio의 여러 인스턴스에서 프로젝트 항목을 끌어 놓을 수 있습니다. 예를 들어 devenv.exe 한 인스턴스에서 다른 인스턴스로 이동 하는 것은 구체적으로 지원 되지 않습니다. 또한이 **솔루션 탐색기** 사용 하지 않도록 설정 합니다.

  사용자는 항상 항목을 선택 하 고 대상 위치로 끌고 항목을 삭제 하기 전에 표시 되는 다음 마우스 포인터를 관찰 하 여 끌어서 놓기 작업의 효과를 확인할 수 있어야 합니다.

|마우스 포인터|명령|Description|
|-------------------|-------------|-----------------|
|![마우스 "끌어 놓기 없음" 아이콘](../../extensibility/ux-guidelines/media/0706-01-mousenodrop.png "0706-01_MouseNoDrop")|삭제 안 함|지정 된 위치로 항목을 삭제할 수 없습니다.|
|![마우스 "복사" 아이콘](../../extensibility/ux-guidelines/media/0706-02-mousecopy.png "0706-02_MouseCopy")|복사|항목이 대상 위치로 복사 됩니다.|
|![마우스 "이동" 아이콘](../../extensibility/ux-guidelines/media/0706-03-mousemove.png "0706-03_MouseMove")|이동|항목이 대상 위치로 이동 됩니다.|
|![마우스 "참조 추가" 아이콘](../../extensibility/ux-guidelines/media/0706-04-mouseaddref.png "0706-04_MouseAddRef")|추가 참조|선택한 항목에 대 한 참조가 대상 위치에 추가 됩니다.|

#### <a name="reference-based-projects"></a>참조 기반 프로젝트
 다음 표에서는 소스 항목의 특성과 참조 기반 대상 프로젝트에 대해 누르는 보조키를 기반으로 수행 해야 하는 끌어서 놓기 (잘라내기/복사/붙여넣기) 작업을 요약 하 여 보여 줍니다.

|한정자|연산|소스 항목: 참조/링크|소스 항목: 물리적 항목 또는 파일 시스템 (CF_HDROP)|
|-|-|----------------------------------|-------------------------------------------------------------|
|한정자 없음|작업|이동|링크|
|한정자 없음|대상|원본 항목에 대 한 참조를 추가 합니다.|원본 항목에 대 한 참조를 추가 합니다.|
|한정자 없음|원본|원본 항목에 대 한 참조를 삭제 합니다.|원래 항목 유지|
|한정자 없음|결과|**DROPEFFECT_MOVE** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|**DROPEFFECT_LINK** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|
|Shift + 끌기|작업|이동|삭제 안 함|
|Shift + 끌기|대상|원본 항목에 대 한 참조를 추가 합니다.|삭제 안 함|
|Shift + 끌기|원본|원본 항목에 대 한 참조를 삭제 합니다.|삭제 안 함|
|Shift + 끌기|결과|**DROPEFFECT_MOVE** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|삭제 안 함|
|Ctrl + 끌기|작업|복사|삭제 안 함|
|Ctrl + 끌기|대상|원본 항목에 대 한 참조를 추가 합니다.|삭제 안 함|
|Ctrl + 끌기|원본|원본 항목에 대 한 참조를 유지 합니다.|삭제 안 함|
|Ctrl + 끌기|결과|**DROPEFFECT_COPY** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|삭제 안 함|
|Ctrl + Shift + 끌기|작업|링크|링크|
|Ctrl + Shift + 끌기|대상|원본 항목에 대 한 참조를 추가 합니다.|원본 항목에 대 한 참조를 추가 합니다.|
|Ctrl + Shift + 끌기|원본|원본 항목에 대 한 참조를 유지 합니다.|원래 항목 유지|
|Ctrl + Shift + 끌기|결과|**DROPEFFECT_LINK** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|**DROPEFFECT_LINK** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|
|Ctrl + Shift + 끌기|참고|Windows 탐색기의 바로 가기에 대 한 끌어서 놓기 동작과 동일 합니다.||
|잘라내기/붙여넣기|작업|이동|링크|
|잘라내기/붙여넣기|대상|원본 항목에 대 한 참조를 추가 합니다.|원본 항목에 대 한 참조를 추가 합니다.|
|잘라내기/붙여넣기|원본|원본 항목에 대 한 참조를 유지 합니다.|원래 항목 유지|
|잘라내기/붙여넣기|결과|항목은 저장소의 원래 위치에 유지 됩니다.|항목은 저장소의 원래 위치에 유지 됩니다.|
|복사/붙여넣기|작업|복사|링크|
|복사/붙여넣기|원본|원본 항목에 대 한 참조를 추가 합니다.|원본 항목에 대 한 참조를 추가 합니다.|
|복사/붙여넣기|결과|원본 항목에 대 한 참조를 유지 합니다.|원래 항목 유지|
|복사/붙여넣기|작업|항목은 저장소의 원래 위치에 유지 됩니다.|항목은 저장소의 원래 위치에 유지 됩니다.|

#### <a name="directory-based-projects"></a>디렉터리 기반 프로젝트
 다음 표에서는 소스 항목의 특성과 디렉터리 기반 대상 프로젝트에 대해 사용 되는 보조키를 기준으로 수행 해야 하는 끌어서 놓기 (잘라내기/복사/붙여넣기) 작업을 요약 합니다.

|한정자|연산|소스 항목: 참조/링크|소스 항목: 물리적 항목 또는 파일 시스템 (CF_HDROP)|
|-|-|----------------------------------|-------------------------------------------------------------|
|한정자 없음|작업|이동|이동|
|한정자 없음|대상|대상 위치에 항목을 복사 합니다.|대상 위치에 항목을 복사 합니다.|
|한정자 없음|원본|원본 항목에 대 한 참조를 삭제 합니다.|원본 항목에 대 한 참조를 삭제 합니다.|
|한정자 없음|결과|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|
|Shift + 끌기|작업|이동|이동|
|Shift + 끌기|대상|대상 위치에 항목을 복사 합니다.|대상 위치에 항목을 복사 합니다.|
|Shift + 끌기|원본|원본 항목에 대 한 참조를 삭제 합니다.|원본 위치에서 항목을 삭제 합니다.|
|Shift + 끌기|결과|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|
|Ctrl + 끌기|작업|복사|복사|
|Ctrl + 끌기|대상|대상 위치에 항목을 복사 합니다.|대상 위치에 항목을 복사 합니다.|
|Ctrl + 끌기|원본|원본 항목에 대 한 참조를 유지 합니다.|원본 항목에 대 한 참조를 유지 합니다.|
|Ctrl + 끌기|결과|**DROPEFFECT_ 복사** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 유지 됩니다.|**DROPEFFECT_ 복사** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 유지 됩니다.|
|Ctrl + Shift + 끌기||삭제 안 함|삭제 안 함|
|잘라내기/붙여넣기|작업|이동|이동|
|잘라내기/붙여넣기|대상|대상 위치에 항목을 복사 합니다.|대상 위치에 항목을 복사 합니다.|
|잘라내기/붙여넣기|원본|원본 항목에 대 한 참조를 삭제 합니다.|원본 위치에서 항목을 삭제 합니다.|
|잘라내기/붙여넣기|결과|항목은 저장소의 원래 위치에 유지 됩니다.|저장소의 원래 위치에서 항목이 삭제 되었습니다.|
|복사/붙여넣기|작업|복사|복사|
|복사/붙여넣기|대상|원본 항목에 대 한 참조를 추가 합니다.|대상 위치에 항목을 복사 합니다.|
|복사/붙여넣기|원본|원래 항목 유지|원래 항목 유지|
|복사/붙여넣기|결과|항목은 저장소의 원래 위치에 유지 됩니다.|항목이 원래 위치 저장소에 유지 됩니다.|

#### <a name="mixed-target-projects"></a>혼합 대상 프로젝트
 다음 표에서는 소스 항목의 특성 및 혼합 대상 프로젝트에 대해 누르는 보조키를 기준으로 수행 해야 하는 끌어서 놓기 (잘라내기/복사/붙여넣기) 작업을 요약 하 여 보여 줍니다.

|한정자|연산|소스 항목: 참조/링크|소스 항목: 물리적 항목 또는 파일 시스템 (CF_HDROP)|
|-|-|----------------------------------|-------------------------------------------------------------|
|한정자 없음|작업|이동|이동|
|한정자 없음|대상|원본 항목에 대 한 참조를 추가 합니다.|대상 위치에 항목을 복사 합니다.|
|한정자 없음|원본|원본 항목에 대 한 참조를 삭제 합니다.|원본 항목에 대 한 참조를 삭제 합니다.|
|한정자 없음|결과|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에서 삭제 됩니다.|
|Shift + 끌기|작업|이동|이동|
|Shift + 끌기|대상|원본 항목에 대 한 참조를 추가 합니다.|대상 위치에 항목을 복사 합니다.|
|Shift + 끌기|원본|원본 항목에 대 한 참조를 삭제 합니다.|원본 위치에서 항목을 삭제 합니다.|
|Shift + 끌기|결과|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 남아 있습니다.|**DROPEFFECT_ 이동** 은의 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에서 삭제 됩니다.|
|Ctrl + 끌기|작업|복사|복사|
|Ctrl + 끌기|대상|원본 항목에 대 한 참조를 추가 합니다.|대상 위치에 항목을 복사 합니다.|
|Ctrl + 끌기|원본|원본 항목에 대 한 참조를 유지 합니다.|원래 항목 유지|
|Ctrl + 끌기|결과|**DROPEFFECT_ 복사** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 유지 됩니다.|**DROPEFFECT_ 복사** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 유지 됩니다.|
|Ctrl + Shift + 끌기|작업|링크|링크|
|Ctrl + Shift + 끌기|대상|원본 항목에 대 한 참조를 추가 합니다.|원본 소스 항목에 참조를 추가 합니다.|
|Ctrl + Shift + 끌기|원본|원본 항목에 대 한 참조를 유지 합니다.|원래 항목 유지|
|Ctrl + Shift + 끌기|결과|**DROPEFFECT_ 링크** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 유지 됩니다.|**DROPEFFECT_ 링크** 는에서 작업으로 반환 됩니다 **.:D rop** 및 항목은 저장소의 원래 위치에 유지 됩니다.|
|잘라내기/붙여넣기|작업|이동|이동|
|잘라내기/붙여넣기|대상|대상 위치에 항목을 복사 합니다.|대상 위치에 항목을 복사 합니다.|
|잘라내기/붙여넣기|원본|원본 항목에 대 한 참조를 삭제 합니다.|원본 위치에서 항목을 삭제 합니다.|
|잘라내기/붙여넣기|결과|항목은 저장소의 원래 위치에 유지 됩니다.|저장소의 원래 위치에서 항목이 삭제 되었습니다.|
|복사/붙여넣기|작업|복사|복사|
|복사/붙여넣기|대상|원본 항목에 대 한 참조를 추가 합니다.|대상 위치에 항목을 복사 합니다.|
|복사/붙여넣기|원본|원래 항목 유지|원래 항목 유지|
|복사/붙여넣기|결과|항목은 저장소의 원래 위치에 유지 됩니다.|항목은 저장소의 원래 위치에 유지 됩니다.|

 이러한 세부 정보는 **솔루션 탐색기**에서 끌기를 구현할 때 고려해 야 합니다.

- 여러 선택 시나리오를 위한 디자인

- 파일 이름 (전체 경로)은 대상 프로젝트에서 고유 해야 합니다. 그렇지 않으면 drop을 사용할 수 없습니다.

- 폴더 이름은 삭제 중인 수준에서 고유 해야 합니다 (대/소문자 구분 안 함).

- 끌 때 열려 있거나 닫혀 있는 파일 간의 동작 차이는 위의 시나리오에서 언급 되지 않습니다.

- 최상위 파일은 폴더의 파일과 약간 다르게 동작 합니다.

  다른 문제에 유의 해야 합니다. 개방형 디자이너 또는 편집기를 포함 하는 항목에 대 한 이동 작업을 처리 하는 방법입니다. 예상 되는 동작은 다음과 같습니다. 모든 프로젝트 형식에 적용 됩니다.

1. 열려 있는 편집기/디자이너에 저장 하지 않은 변경 내용이 없으면 편집기/디자이너 창이 자동으로 닫힙니다.

2. 열려 있는 편집기/디자이너에서 저장 되지 않은 변경 내용이 있는 경우 끌기의 소스는 놓기가 발생할 때까지 기다린 다음 창이 닫히기 전에 열려 있는 문서의 커밋되지 않은 변경 내용을 저장 하도록 요청 하 고 다음과 유사한 메시지가 표시 됩니다.

   ```
   ==========================================================
        One or more open documents have unsaved changes.
   Do you want to save uncommitted changes before proceeding?
                     [Yes]  [No]  [Cancel]
   ==========================================================
   ```

   이렇게 하면 대상에서 복사본을 만들기 전에 진행 중인 작업을 저장할 수 있습니다. 이 처리를 사용할 수 있도록 새 메서드 **IVsHierarchyDropDataSource2:: OnBeforeDropNotify** 가 추가 되었습니다.

   그러면 대상이 저장소에 있는 항목의 상태를 복사 합니다 (사용자가 **아니요**를 선택한 경우 편집기에 저장 되지 않은 변경 내용을 포함 하지 않음). **IVsHierarchyDropDataSource::D rop**에서 대상이 복사를 완료 한 후에는 원본에 이동 작업의 삭제 부분 ( **IVsHierarchyDropDataSource:: ondropnotify**)을 완료할 수 있는 기회가 제공 됩니다.

   저장 하지 않은 변경 내용이 있는 모든 편집기는 열린 상태로 두어야 합니다. 저장 하지 않은 변경 내용이 있는 문서에 대해서는 이동 작업의 복사 부분이 수행 되지만 삭제 부분이 중단 됨을 의미 합니다. 사용자가 **아니요**를 선택 하는 경우 여러 선택 시나리오에서 저장 되지 않은 변경 내용이 있는 문서는 닫히거나 제거 되어서는 안 됩니다. 그러나 저장 하지 않은 변경 내용이 없는 문서는 닫은 후 제거 해야 합니다.
