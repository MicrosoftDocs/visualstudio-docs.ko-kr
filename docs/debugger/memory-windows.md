---
title: 디버거에서 변수에 대한 메모리 보기 | Microsoft Docs
ms.custom: ''
ms.date: 10/04/2018
ms.topic: conceptual
f1_keywords:
- vs.debug.memory
dev_langs:
- CSharp
- VB
- FSharp
- C++
- JScript
helpviewer_keywords:
- Memory window
- strings [Visual Studio], viewing
- debugger [Visual Studio], Memory window
- memory [Visual Studio], debugging
- debugging [Visual Studio], Memory window
- buffers, viewing
ms.assetid: 7f7a0439-10e4-4966-bb2d-51f04cda4fe2
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 794400a14cac5b85f813e7a384c650c581a719e2
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62905580"
---
# <a name="use-the-memory-windows-in-the-visual-studio-debugger-c-c-visual-basic-f"></a>Visual Studio 디버거에서 메모리 창 사용(C#, C++, Visual Basic, F#)

디버그하는 동안 **메모리** 창에는 앱에서 사용 중인 메모리 공간이 표시됩니다.

**조사식**, **자동**, **로컬**, **간략한 조사식** 대화 상자와 같은 디버거 창에서는 메모리의 특정 위치에 저장되는 변수를 보여 줍니다. **메모리** 창에서 전체 상황이 표시됩니다. 메모리 뷰는 다른 창들에는 잘 표시되지 않는 버퍼나 큰 문자열 등의 큰 데이터를 검사하는 데 편리합니다.

**메모리** 창이 데이터를 표시하는 데만 한정되지는 않습니다. 메모리 창에서는 할당되지 않은 메모리의 데이터, 코드 및 임의 가비지 비트를 포함한 모든 내용을 메모리 공간에 표시합니다.

스크립트 또는 SQL 디버깅에는 **메모리** 창을 사용할 수 없습니다. 이러한 언어는 메모리의 개념을 인식하지 못합니다.

## <a name="open-a-memory-window"></a>메모리 창 열기

다른 디버거 창과 마찬가지로 **메모리** 창은 디버그 세션 중에만 사용할 수 있습니다.

>[!IMPORTANT]
>**메모리** 창을 사용하도록 설정하려면 **도구** > **옵션**(또는 **디버그** > **옵션**) > **디버깅** > **일반**에서 **주소 수준 디버깅 사용**을 선택해야 합니다.

**메모리 창을 열려면**

1. **도구** > **옵션**(또는 **디버그** > **옵션**) > **디버깅** > **일반**에서 **주소 수준 디버깅 사용**을 선택합니다.

1. 녹색 화살표를 선택하고 **F5** 키를 누르거나 **디버그** > **디버깅 시작**을 선택하여 디버깅을 시작합니다.

2. **디버그** > **창** > **메모리**에서 **메모리 1**, **메모리 2**, **메모리 3** 또는 **메모리 4**를 선택합니다. 일부 [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] 버전에서는 **메모리** 창을 하나만 제공합니다.

## <a name="move-around-in-the-memory-window"></a>메모리 창에서 이동

컴퓨터의 주소 공간은 크기 때문에 **메모리** 창에서 스크롤하면 쉽게 위치를 잃을 수 있습니다.

메모리 주소가 높을수록 창의 아래쪽에 나타납니다. 따라서 상위 주소를 확인하려면 아래로 스크롤하고 하위 주소를 보려면 위로 스크롤합니다.

**메모리** 창에서 끌어서 놓기를 사용하거나 **주소** 필드에 주소를 입력하여 지정된 주소로 즉시 이동할 수 있습니다. **주소** 필드는 영숫자 주소와 주소(예: `e.User.NonroamableId`)로 계산되는 식을 허용합니다.

**주소** 필드에서 식을 즉시 다시 계산하려면 둥근 화살표가 있는 **자동으로 다시 계산** 아이콘을 선택합니다.

기본적으로 **메모리** 창에서는 **주소** 식을 앱이 실행될 때 다시 계산되는 라이브 식으로 처리합니다. 예를 들어 라이브 식은 포인터 변수에서 작업하는 메모리를 확인하는 데 유용할 수 있습니다.

**끌어서 놓기를 사용하여 메모리 위치로 이동하려면:**

1. 임의의 디버거 창에서 메모리 주소가 포함된 메모리 주소 또는 포인터 변수를 선택합니다.

2. **메모리** 창에서 주소 또는 포인터를 끌어서 놓습니다. 그러면 해당 주소가 **주소** 필드에 표시되고 **메모리** 창이 조정되어 해당 주소가 위쪽에 표시됩니다.

**주소 필드에 입력하여 메모리 위치로 이동하려면:**

- **주소** 필드에 주소 또는 식을 입력하거나 붙여넣고 **Enter** 키를 누르거나, **주소** 필드의 드롭다운에서 선택합니다. **메모리** 창이 조정되어 해당 주소가 위쪽에 표시됩니다.

## <a name="customize-the-memory-window"></a>메모리 창 사용자 지정

기본적으로 메모리 내용은 16진수 형식의 1바이트 정수로 표시되고, 표시되는 열 수는 창의 너비에 따라 정해집니다. **메모리** 창에 메모리 내용이 표시되는 방식을 사용자 지정할 수 있습니다.

**메모리 내용의 형식을 변경하려면:**

- **메모리** 창을 마우스 오른쪽 단추로 클릭하고 상황에 맞는 메뉴에서 원하는 형식을 선택합니다.

**메모리 창에 표시된 열 수를 변경하려면:**

- **열** 필드 옆에 있는 드롭다운 화살표를 선택하고 표시할 열 수를 선택하거나, 창 너비에 따라 자동으로 조정되도록 **자동**을 선택합니다.

앱이 실행될 때 **메모리** 창의 내용을 변경하지 않으려는 경우 라이브 식 계산을 해제할 수 있습니다.

**라이브 계산을 설정/해제하려면:**

- **메모리** 창을 마우스 오른쪽 단추로 클릭하고 상황에 맞는 메뉴에서 **자동으로 다시 계산**을 선택합니다.

  >[!NOTE]
  >라이브 식 계산은 토글이며 기본적으로 설정되어 있으므로 **자동으로 다시 계산**을 선택하면 기능이 해제됩니다. **자동으로 다시 계산**을 선택하면 다시 설정됩니다.

**메모리** 창 맨 위에 있는 도구 모음을 숨기거나 표시할 수 있습니다. 도구 모음이 숨겨져 있을 때는 **주소** 필드나 기타 도구에 액세스할 수 없습니다.

**도구 모음 표시를 설정/해제하려면:**

- **메모리** 창을 마우스 오른쪽 단추로 클릭하고 상황에 맞는 메뉴에서 **도구 모음 표시**를 선택합니다. 도구 모음의 이전 상태에 따라 도구 모음이 나타나거나 없어집니다.

## <a name="follow-a-pointer-through-memory"></a>포인터가 가리키는 메모리 표시

네이티브 코드 앱에서는 레지스터 이름을 라이브 식으로 사용할 수 있습니다. 예를 들어, 스택 포인터를 사용하여 스택을 따를 수 있습니다.

**포인터가 가리키는 메모리를 표시하려면:**

1. **메모리** 창의 **주소** 필드에 현재 범위에 있는 포인터 식을 입력합니다. 사용하는 언어에 따라 포인터 변수를 역참조해야 할 수도 있습니다.

2. **Enter** 키를 누릅니다.

   **Step**과 같은 디버그 명령을 사용하는 경우 메모리 주소는 포인터가 변경됨에 따라 **주소** 필드 및 **메모리** 창 위쪽에 자동으로 표시됩니다.

## <a name="see-also"></a>참조
- [디버거에서 데이터 보기](../debugger/viewing-data-in-the-debugger.md)